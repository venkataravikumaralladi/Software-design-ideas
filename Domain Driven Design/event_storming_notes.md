EventStorming is a low-tech activity for a group of people to brainstorm and rapidly model a business process. In a sense, EventStorming is a tactical tool for sharing business domain knowledge. An EventStorming session has a scope: the business process that the group is interested in exploring. The participants are exploring the process as a series of domain events, represented by sticky notes, over a timeline. Step by step, the model is enhanced with additional concepts—actors, commands, entities, language,  external systems, and others—until all of its elements tell the story of how the business process works.

Event storming is `collobarative technique` that developer/architect will do with business people in order to come up with a design of a system that models the structure and flow of activities within the business. Note here stories are also important i.e., do the modeling according to the business

`So you sitdown with a story and a bunch of business people and a white board and a bunch of sticky notes and you start modeling.`

![image](https://user-images.githubusercontent.com/10434795/197523522-e3afe931-c7b1-4a5f-b579-b86ad8a6e35e.png)

#### Event storming process

1. First order of business with event storming is business events, and that we write one event per sticky note and arrange the sticky notes from left to right on wihte board. Note these are not programming model level events though this may happen later but these may not happen at beginners. These are business level events.
2. Second order of business is that we will go through events and for each event we will decide what activity (i.e., action, command) has to occur as a result of the event being received.
3. Third order of business is that we decide what aggregate or context or entity is responsible for receiving tthe event and doing the activity
4. Fourth order of business is that we might have optional questions.
5. Fifth order of business that there might be a work product being generated for example a pick list might come out of an order being placed. An invoice, or something like that might be generated by a financial event.
6. Sixth order of business is about adding policies

Once above steps have done we can add little more information. So in case of events we might be interested in what payload the events carry along with them. So the fact that an order has been placed might carry some information with it. For example, the items that comprised the order contains the destination address or something like that. Similarly, the aggregate or the entity, rather, occurs within some context. Sow we are starting to identify both the events and the context within which those events occur.

So to summarize, here we user various colors that you might see in one of the systems. We have events in `orange`, we have commands (actions) in `blue`, aggregates or entities in `yellow`. `green` might identify an actor or some kind of UI activity occuring within the system. And then there are business processes or policies, external system from which events come or to which events are sent, work products, and then finally questions in `red`.

#### Generally used color notations

`Event (Orange)`: An event is something that happens at the business level that customers (end users or domain experts) care about. Rememeber that event is a business level thing that we are implementing the domain. Example of events are order submitted, payment recevied, nightly reconciliation completed. We don't really care who is triggering the event. What we care is the event itself. Also notice that the events are specified in past tense and that's also important. An event is some thing that has happened that will trigger some thing else to happen to next. So putting the events in past tense is a good way to keep them straight, and organize the system. Arrange the events in time line. The events should start with the “happy path scenario”: the flow that describes a successful business scenario. Once the “happy path” is done, alternative scenarios can be added

`Actions or actvities or commands (blue)`: Here basic idea here is that an event happens and that causes an action to occur. Basic idea is that you start with the events, and then you say okay wehn this event happens what do we want to happen as a result i.e., we take action and then that goes up as a blue note. Blue notes and orange notes generally tend to inter-oven. Whereas a domain event describes something that has already happened, a command describes what triggered the event or flow of events. Commands describe the system’s operations and, contrary to domain events, are formulated in the imperative (i.e., commanding, expressing a command). For example: Publish campaign, Roll back transaction, Submit order. Below impage helps in understanding.

![image](https://user-images.githubusercontent.com/10434795/203340143-bba5f7cf-f2de-4910-b67f-6bb3a7957197.png)

`questions (red)`: some times when we are thinking of events and actions we don't know what we have to do. They are the questions that occured in the process of doing the modeling, where the modeling is not complete. As long as red sticky note is there we are not ready to code yet.

`policies (purple)`: policy or business rule that is going to control how the action plays out. So when the event is received, you might then apply a policy and decide what to do next based on what that policy says. So policies are ways to indicate that it is not a smooth linear flow. There are decisions that have to be made here based on some set of business rules.

![image](https://user-images.githubusercontent.com/10434795/203341248-62a5828c-eb2f-4b53-87d0-868b7b81b909.png)

`aggregates or entities (yellow)`: work product being generated or aggregate or entity that takes an action or command. For example an invoice might be an product that is generated by a financial event. So basically once we have basic flow of events i.e., flow under control, we have to start thinking about not `what` is happending but `how` it is happening i.e., in other words who is doing it. For example if the cart has been purchased which is an event, and we need to issue an invoice which is command or action or activities. Who is going to do that i.e., invoice. In this example let us use sales clerk or cashier or controller who is an entity. Example is shown below. Note we have entities like cashier, sales clerk, etc who do activities when events occurs. It is possible that during initial phase wed don't know that we ahvve covered all entities or aggregates which will evolve over a period of time.

![image](https://user-images.githubusercontent.com/10434795/203937753-95184c69-9c4a-4545-ad8a-3a41f40ee9b1.png)

`pivot events:` Once you have a timeline of events, look for significant business events indicating a change in context or phase. These are called pivotal
events and are marked with a vertical bar dividing the events before and after the pivotal event. For example, “shopping cart initialized,” “order initialized,” “order shipped,” “order delivered,” and “order returned” represent significant changes in the process of making an order, as shown in below figure.

![image](https://user-images.githubusercontent.com/10434795/203343077-180ae161-b02c-43c6-80e8-4fa66b02f8f3.png)

`external systems(pink)`: occured from outside world.

`entity or aggregates (yellow)`: Below picture shows Aggregates are represented as large yellow sticky notes, with commands on the left and events on the right.

![image](https://user-images.githubusercontent.com/10434795/197548112-a26e3487-1e41-447d-9135-065bb39585f9.png)

#### Contexts
Below picture shows a possible decomposition of the resultant system into bounded contexts.From entities we know who handle events. Now let us see under what contexts entites fall in place. We will add contexts on entities sticker or itself has it own sticker. 

![image](https://user-images.githubusercontent.com/10434795/197548480-cdfc1e94-c80a-409f-907f-d93f81bf3b4f.png)

Below example show a snap shot of output of event storming. So now we have the events (orange). We have activities or actions or commands (blue color) to perform after the events are received. We know who (entity yellow color) is receiving the event and doing the activity. Those are yellow entity notes, and we know the bounded context within which these entities are working.

![image](https://user-images.githubusercontent.com/10434795/203941988-34fa09c8-a31f-409e-bae3-16f96b7f4cbe.png)


#### Output of event storming

When we are done with event storming then we end up with a long piece of paper with a lot of sticky notes on it, but what that shows us is the entire fflow of events through a system as a story is being processed, who is handling all those events, and what context they are part of to name a few.  So this will help developer to program in easy way from the model.

The resultant model covers a wide range of the company’s business domain, builds a strong foundation for ubiquitous languages,and outlines possible boundaries for bounded contexts. After gaining the big picture and identifying the different business processes, we continue to facilitate a dedicated EventStorming session for each relevant business process—  this time, following all the steps to model the complete process.

At the end of a full EventStorming session, you will have a model describing the business domain’s events, commands, aggregates, and even possible bounded contexts.
However, all of these are just nice bonuses. The real value of an EventStorming session is the process itself—the sharing of knowledge among different stakeholders,
alignment of their mental models of the business, discovery of conflicting models, and, last but not least, formulation of the ubiquitous language.

So this is really enough to code from, now we have a basic design here that is mapping the domain, that is using the domain level terminology in order to keep things straight i.e., when things happen at the domain level, we know exactly where to go on our map in order to make things work. And really we are just ready to code. For example we created shipping clerks, agents, dispatchers. Those could be mircoservices or classes if we are working inside a big monolith instead. We know what events are, how they are sent, who receives them. We are ready to code. So this is the basic coding process.

#### Tools for performing event storming

We can use miro tool (https://miro.com/login/)




