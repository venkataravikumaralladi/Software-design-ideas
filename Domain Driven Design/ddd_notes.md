
The domain is a fancy way of saying the problem you’re trying to solve. Depending on which system you’re talking about about, the domain might be online reailer,
purchasing and procurement, or product design, or logistics and delivery, industrial product, bank product etc.  Software developer spend their days trying to
improve or automate business processes physically happening in real time world in secured and safety manner ; the domain is the set of activities that those
processes support. A model is a map of a process or phenomenon that captures a useful property.
The domain model is the mental map that business owners have of their businesses. 

Domain-driven design will make you a more effective software engineer by alleviating the process of making sense of business domains and guiding the design decisions according to the business strategy. The tighter the connection between the software design and its business strategy is, the easier it will be to maintain and evolve the system to meet the future needs of the business, ultimately leading to more successful software projects.

Effective communication is the central theme of the domain-driven design tools and practices DDD can be divided into two parts: strategic and tactical.

The strategic tools of DDD are used to analyze business domains and strategy, and to foster a shared understanding of the business between the different stakeholders.
We will also use this knowledge of the business domain to drive high-level design decisions:decomposing systems into components and defining their integration patterns. The `strategic` aspect of DDD deals with answering the questions of `“what?”` and `“why?”` —what software we are building and why we are building it. 

Domain-driven design’s tactical tools address a different aspect of communication issues. DDD’s `tactical patterns` allow us to write code in a way that reflects
the business domain, addresses its goals, and speaks the language of the business. The tactical part is all about the “how”—how each component is `implemented`.


Domain-driven design is even more important for software architects, and even more so for aspiring software architects. Its strategic design decision tools will 
help you decompose a large system into components—services, microservices, or subsystems—and design how the components are integrated with one another to form
a system.
